/*
 * StackExchange
 * Stack Exchange is a network of 130+ Q&A communities including Stack Overflow. 
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.model.AccountMergeInner;
import com.konfigthis.client.model.AnswersInner;
import com.konfigthis.client.model.BadgesInner;
import com.konfigthis.client.model.CommentsInner;
import com.konfigthis.client.model.InboxItemsInner;
import com.konfigthis.client.model.NetworkUsersInner;
import com.konfigthis.client.model.NotificationsInner;
import com.konfigthis.client.model.PrivilegesInner;
import com.konfigthis.client.model.QuestionsInner;
import com.konfigthis.client.model.ReputationChangesInner;
import com.konfigthis.client.model.ReputationHistoryInner;
import com.konfigthis.client.model.SuggestedEditsInner;
import com.konfigthis.client.model.TagsInner;
import com.konfigthis.client.model.TopTagObjectsInner;
import com.konfigthis.client.model.User;
import com.konfigthis.client.model.UserTimelineObjectsInner;
import com.konfigthis.client.model.UsersInner;
import com.konfigthis.client.model.WritePermissionsInner;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeAll;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * API tests for UserApi
 */
@Disabled
public class UserApiTest {

    private static UserApi api;

    
    @BeforeAll
    public static void beforeClass() {
        ApiClient apiClient = Configuration.getDefaultApiClient();
        api = new UserApi(apiClient);
    }

    /**
     * Returns all of a user&#39;s associated accounts, given their account_ids in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.   This method returns a list of network_users. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getAssociatedAccountsTest() throws ApiException {
        String ids = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<NetworkUsersInner> response = api.getAssociatedAccounts(ids)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Get the comments posted by users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getCommentsByIdsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<CommentsInner> response = api.getCommentsByIds(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Get the questions that users in {ids} have favorited.   This method is effectively a view onto a user&#39;s favorites tab.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score  - added - when the user favorited the question   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFavoritesListTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<QuestionsInner> response = api.getFavoritesList(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets the questions on which the users in {ids} have active bounties.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFeaturedQuestionsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<QuestionsInner> response = api.getFeaturedQuestions(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a user&#39;s full reputation history, including private events.   This method requires an access_token, with a scope containing \&quot;private_info\&quot;.   This method returns a list of reputation_history. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getFullReputationHistoryTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<ReputationHistoryInner> response = api.getFullReputationHistory(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a user&#39;s inbox.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getInboxItemsTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<InboxItemsInner> response = api.getInboxItems(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the unread items in a user&#39;s inbox.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getInboxUnreadTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        Integer since = null;
        List<InboxItemsInner> response = api.getInboxUnread(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .since(since)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a user&#39;s notifications.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method returns a list of notifications. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getNotificationsListTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<NotificationsInner> response = api.getNotificationsList(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the privileges a user has.   Applications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.   {id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of privileges. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getPrivilegesListTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<PrivilegesInner> response = api.getPrivilegesList(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets the questions asked by the users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getQuestionsByUserIdsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<QuestionsInner> response = api.getQuestionsByUserIds(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets a subset of the reputation changes for users in {ids}.   Reputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of reputation objects. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getReputationChangesTest() throws ApiException {
        String ids = null;
        String site = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<ReputationChangesInner> response = api.getReputationChanges(ids, site)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns users&#39; public reputation history.   This method returns a list of reputation_history. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getReputationHistoryTest() throws ApiException {
        String ids = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<ReputationHistoryInner> response = api.getReputationHistory(ids, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the suggested edits a users in {ids} have submitted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the suggested_edit object:  - creation - creation_date  - approval - approval_date Does not return unapproved suggested_edits  - rejection - rejection_date Does not return unrejected suggested_edits   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of suggested-edits. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getSuggestedEditsByIdsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<SuggestedEditsInner> response = api.getSuggestedEditsByIds(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the tags the users identified in {ids} have been active in.   This route corresponds roughly to user&#39;s stats tab, but does not include tag scores. A subset of tag scores are available (on a single user basis) in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tags. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getTagsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<TagsInner> response = api.getTags(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a single user&#39;s top tags by question score.   This a subset of the data returned on a user&#39;s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getTopQuestionTagsTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<TopTagObjectsInner> response = api.getTopQuestionTags(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the top 30 questions a user has asked with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getTopQuestionsByTagsTest() throws ApiException {
        Integer id = null;
        String tags = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<QuestionsInner> response = api.getTopQuestionsByTags(id, tags, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.   Questions returned by this method have answers, but the owner has not opted to accept any of them.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUnacceptedQuestionsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<QuestionsInner> response = api.getUnacceptedQuestions(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.   These rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.   To get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUnansweredQuestionsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<QuestionsInner> response = api.getUnansweredQuestions(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a user&#39;s unread notifications.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method returns a list of notifications. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUnreadNotificationsTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<NotificationsInner> response = api.getUnreadNotifications(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the user associated with the passed access_token.   This method returns a user. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserTest() throws ApiException {
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        User response = api.getUser(site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the answers the users in {ids} have posted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserAnswersListTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<AnswersInner> response = api.getUserAnswersList(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.   This method is useful for extracting conversations, especially over time or across multiple posts.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserCommentsByIdsAndToidTest() throws ApiException {
        String ids = null;
        Integer toid = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<CommentsInner> response = api.getUserCommentsByIdsAndToid(ids, toid, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets the users identified in ids in {ids}.   Typically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserProfilesByIdsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<UsersInner> response = api.getUserProfilesByIds(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a subset of the actions the users in {ids} have taken on the site.   This method returns users&#39; posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of user timeline objects. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserTimelineByIdsTest() throws ApiException {
        String ids = null;
        String site = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<UserTimelineObjectsInner> response = api.getUserTimelineByIds(ids, site)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a single user&#39;s top tags by answer score.   This a subset of the data returned on a user&#39;s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserTopAnswerTagsTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<TopTagObjectsInner> response = api.getUserTopAnswerTags(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the top 30 answers a user has posted in response to questions with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getUserTopAnswersTest() throws ApiException {
        Integer id = null;
        String tags = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<AnswersInner> response = api.getUserTopAnswers(id, tags, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns the write permissions a user has via the api.   The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.   This method does not consider the user&#39;s current quota (ie. if they&#39;ve already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.   This method returns a list of write_permissions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void getWritePermissionsTest() throws ApiException {
        Integer id = null;
        String site = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<WritePermissionsInner> response = api.getWritePermissions(id, site)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns a record of merges that have occurred involving the passed account ids.   This method allows you to take now invalid account ids and find what account they&#39;ve become, or take currently valid account ids and find which ids were equivalent in the past.   This is most useful when confirming that an account_id is in fact \&quot;new\&quot; to an application.   Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.   Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.   This method returns a list of account_merge. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listAccountMergesTest() throws ApiException {
        String ids = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<AccountMergeInner> response = api.listAccountMerges(ids)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns those users on a site who both have moderator powers, and were actually elected.   This method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listElectedModeratorUsersTest() throws ApiException {
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<UsersInner> response = api.listElectedModeratorUsers(site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets those users on a site who can exercise moderation powers.   Note, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listModeratorUsersTest() throws ApiException {
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<UsersInner> response = api.listModeratorUsers(site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets the questions asked by the users in {ids} which have no answers.   Questions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listNoAnswerQuestionsTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<QuestionsInner> response = api.listNoAnswerQuestions(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Get the badges the users in {ids} have earned.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges a user has by passing min&#x3D;tag_based, and conversely all the named badges by passing max&#x3D;named, with sort&#x3D;type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort&#x3D;rank, set max&#x3D;gold for just gold badges, max&#x3D;silver&amp;min&#x3D;silver for just silver, and min&#x3D;bronze for just bronze.   rank is the default sort.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of badges. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listUserBadgesTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<BadgesInner> response = api.listUserBadges(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Returns all users on a site.   This method returns a list of users.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     The inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname&#x3D;kevin will return all users with both users named simply \&quot;Kevin\&quot; or those with Kevin as one of (or part of) their names; such as \&quot;Kevin Montrose\&quot;. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void listUsersTest() throws ApiException {
        String site = null;
        String inname = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<UsersInner> response = api.listUsers(site)
                .inname(inname)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

    /**
     * Gets all the comments that the users in {ids} were mentioned in.   Note, to count as a mention the comment must be considered to be \&quot;in reply to\&quot; a user. Most importantly, this means that a comment can only be in reply to a single user.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void mentionedCommentsListTest() throws ApiException {
        String ids = null;
        String site = null;
        String order = null;
        String max = null;
        String min = null;
        String sort = null;
        Integer fromdate = null;
        Integer todate = null;
        Integer pagesize = null;
        Integer page = null;
        String filter = null;
        String paramCallback = null;
        List<CommentsInner> response = api.mentionedCommentsList(ids, site)
                .order(order)
                .max(max)
                .min(min)
                .sort(sort)
                .fromdate(fromdate)
                .todate(todate)
                .pagesize(pagesize)
                .page(page)
                .filter(filter)
                .paramCallback(paramCallback)
                .execute();
        // TODO: test validations
    }

}
