/*
 * StackExchange
 * Stack Exchange is a network of 130+ Q&A communities including Stack Overflow. 
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.BadgesInner;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class BadgeApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public BadgeApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public BadgeApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call getAllNamedBadgesCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/badges/name";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inname != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inname", inname));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAllNamedBadgesValidateBeforeCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getAllNamedBadges(Async)");
        }

        return getAllNamedBadgesCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> getAllNamedBadgesWithHttpInfo(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getAllNamedBadgesValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getAllNamedBadgesAsync(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAllNamedBadgesValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetAllNamedBadgesRequestBuilder {
        private final String site;
        private String inname;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetAllNamedBadgesRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set inname
         * @param inname  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder inname(String inname) {
            this.inname = inname;
            return this;
        }
        
        /**
         * Set order
         * @param order  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetAllNamedBadgesRequestBuilder
         */
        public GetAllNamedBadgesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getAllNamedBadges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getAllNamedBadgesCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getAllNamedBadges request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = getAllNamedBadgesWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getAllNamedBadges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return getAllNamedBadgesWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getAllNamedBadges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return getAllNamedBadgesAsync(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets all explicitly named badges in the system.   A named badged stands in opposition to a tag-based badge. These are referred to as general badges on the sites themselves.   For the rank sort, bronze is greater than silver which is greater than gold. Along with sort&#x3D;rank, set max&#x3D;gold for just gold badges, max&#x3D;silver&amp;min&#x3D;silver for just silver, and min&#x3D;bronze for just bronze.   rank is the default sort.   This method returns a list of badges. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetAllNamedBadgesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetAllNamedBadgesRequestBuilder getAllNamedBadges(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetAllNamedBadgesRequestBuilder(site);
    }
    private okhttp3.Call getBadgesByIdsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/badges/{ids}"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getBadgesByIdsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getBadgesByIds(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getBadgesByIds(Async)");
        }

        return getBadgesByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> getBadgesByIdsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getBadgesByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getBadgesByIdsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getBadgesByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetBadgesByIdsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetBadgesByIdsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetBadgesByIdsRequestBuilder
         */
        public GetBadgesByIdsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getBadgesByIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getBadgesByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getBadgesByIds request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = getBadgesByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getBadgesByIds request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return getBadgesByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getBadgesByIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return getBadgesByIdsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the badges identified in id.   Note that badge ids are not constant across sites, and thus should be looked up via the /badges method. A badge id on a single site is, however, guaranteed to be stable.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges by passing min&#x3D;tag_based, and conversely all the named badges by passing max&#x3D;named, with sort&#x3D;type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort&#x3D;rank, set max&#x3D;gold for just gold badges, max&#x3D;silver&amp;min&#x3D;silver for just silver, and min&#x3D;bronze for just bronze.   rank is the default sort.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for badge_id on badge objects.   This method returns a list of badges. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetBadgesByIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetBadgesByIdsRequestBuilder getBadgesByIds(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetBadgesByIdsRequestBuilder(ids, site);
    }
    private okhttp3.Call getRecentAwardedBadgesCall(String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/badges/recipients";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecentAwardedBadgesValidateBeforeCall(String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getRecentAwardedBadges(Async)");
        }

        return getRecentAwardedBadgesCall(site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> getRecentAwardedBadgesWithHttpInfo(String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getRecentAwardedBadgesValidateBeforeCall(site, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getRecentAwardedBadgesAsync(String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecentAwardedBadgesValidateBeforeCall(site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetRecentAwardedBadgesRequestBuilder {
        private final String site;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetRecentAwardedBadgesRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetRecentAwardedBadgesRequestBuilder
         */
        public GetRecentAwardedBadgesRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetRecentAwardedBadgesRequestBuilder
         */
        public GetRecentAwardedBadgesRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetRecentAwardedBadgesRequestBuilder
         */
        public GetRecentAwardedBadgesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetRecentAwardedBadgesRequestBuilder
         */
        public GetRecentAwardedBadgesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetRecentAwardedBadgesRequestBuilder
         */
        public GetRecentAwardedBadgesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetRecentAwardedBadgesRequestBuilder
         */
        public GetRecentAwardedBadgesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getRecentAwardedBadges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getRecentAwardedBadgesCall(site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getRecentAwardedBadges request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = getRecentAwardedBadgesWithHttpInfo(site, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getRecentAwardedBadges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return getRecentAwardedBadgesWithHttpInfo(site, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getRecentAwardedBadges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return getRecentAwardedBadgesAsync(site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns recently awarded badges in the system.   As these badges have been awarded, they will have the badge.user property set.   This method returns a list of badges. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetRecentAwardedBadgesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetRecentAwardedBadgesRequestBuilder getRecentAwardedBadges(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetRecentAwardedBadgesRequestBuilder(site);
    }
    private okhttp3.Call getRecentAwardedRecipientsCall(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/badges/{ids}/recipients"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getRecentAwardedRecipientsValidateBeforeCall(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getRecentAwardedRecipients(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getRecentAwardedRecipients(Async)");
        }

        return getRecentAwardedRecipientsCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> getRecentAwardedRecipientsWithHttpInfo(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getRecentAwardedRecipientsValidateBeforeCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getRecentAwardedRecipientsAsync(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getRecentAwardedRecipientsValidateBeforeCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetRecentAwardedRecipientsRequestBuilder {
        private final String ids;
        private final String site;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetRecentAwardedRecipientsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetRecentAwardedRecipientsRequestBuilder
         */
        public GetRecentAwardedRecipientsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetRecentAwardedRecipientsRequestBuilder
         */
        public GetRecentAwardedRecipientsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetRecentAwardedRecipientsRequestBuilder
         */
        public GetRecentAwardedRecipientsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetRecentAwardedRecipientsRequestBuilder
         */
        public GetRecentAwardedRecipientsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetRecentAwardedRecipientsRequestBuilder
         */
        public GetRecentAwardedRecipientsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetRecentAwardedRecipientsRequestBuilder
         */
        public GetRecentAwardedRecipientsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getRecentAwardedRecipients
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getRecentAwardedRecipientsCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getRecentAwardedRecipients request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = getRecentAwardedRecipientsWithHttpInfo(ids, site, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getRecentAwardedRecipients request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return getRecentAwardedRecipientsWithHttpInfo(ids, site, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getRecentAwardedRecipients request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return getRecentAwardedRecipientsAsync(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns recently awarded badges in the system, constrained to a certain set of badges.   As these badges have been awarded, they will have the badge.user property set.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for badge_id on badge objects.   This method returns a list of badges. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetRecentAwardedRecipientsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetRecentAwardedRecipientsRequestBuilder getRecentAwardedRecipients(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetRecentAwardedRecipientsRequestBuilder(ids, site);
    }
    private okhttp3.Call getUserBadgesCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/me/badges";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserBadgesValidateBeforeCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUserBadges(Async)");
        }

        return getUserBadgesCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> getUserBadgesWithHttpInfo(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserBadgesValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserBadgesAsync(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserBadgesValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserBadgesRequestBuilder {
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserBadgesRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserBadgesRequestBuilder
         */
        public GetUserBadgesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUserBadges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserBadgesCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUserBadges request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = getUserBadgesWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserBadges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return getUserBadgesWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUserBadges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return getUserBadgesAsync(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the badges earned by the user associated with the given access_token.   This method returns a list of badges. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserBadgesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserBadgesRequestBuilder getUserBadges(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserBadgesRequestBuilder(site);
    }
    private okhttp3.Call listBadgesCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/badges";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inname != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inname", inname));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listBadgesValidateBeforeCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listBadges(Async)");
        }

        return listBadgesCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> listBadgesWithHttpInfo(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listBadgesValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listBadgesAsync(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listBadgesValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListBadgesRequestBuilder {
        private final String site;
        private String inname;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListBadgesRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set inname
         * @param inname  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder inname(String inname) {
            this.inname = inname;
            return this;
        }
        
        /**
         * Set order
         * @param order  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListBadgesRequestBuilder
         */
        public ListBadgesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listBadges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listBadgesCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listBadges request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = listBadgesWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listBadges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return listBadgesWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listBadges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return listBadgesAsync(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns all the badges in the system.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges by passing min&#x3D;tag_based, and conversely all the named badges by passing max&#x3D;named, with sort&#x3D;type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort&#x3D;rank, set max&#x3D;gold for just gold badges, max&#x3D;silver&amp;min&#x3D;silver for just silver, and min&#x3D;bronze for just bronze.   rank is the default sort.   This method returns a list of badges. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListBadgesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListBadgesRequestBuilder listBadges(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListBadgesRequestBuilder(site);
    }
    private okhttp3.Call listTagsBadgesCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/badges/tags";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inname != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inname", inname));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listTagsBadgesValidateBeforeCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listTagsBadges(Async)");
        }

        return listTagsBadgesCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> listTagsBadgesWithHttpInfo(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listTagsBadgesValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listTagsBadgesAsync(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listTagsBadgesValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListTagsBadgesRequestBuilder {
        private final String site;
        private String inname;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListTagsBadgesRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set inname
         * @param inname  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder inname(String inname) {
            this.inname = inname;
            return this;
        }
        
        /**
         * Set order
         * @param order  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListTagsBadgesRequestBuilder
         */
        public ListTagsBadgesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listTagsBadges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listTagsBadgesCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listTagsBadges request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = listTagsBadgesWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listTagsBadges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return listTagsBadgesWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listTagsBadges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return listTagsBadgesAsync(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the badges that are awarded for participation in specific tags.   For the rank sort, bronze is greater than silver which is greater than gold. Along with sort&#x3D;rank, set max&#x3D;gold for just gold badges, max&#x3D;silver&amp;min&#x3D;silver for just silver, and min&#x3D;bronze for just bronze.   rank is the default sort.   This method returns a list of badges. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListTagsBadgesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListTagsBadgesRequestBuilder listTagsBadges(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListTagsBadgesRequestBuilder(site);
    }
}
