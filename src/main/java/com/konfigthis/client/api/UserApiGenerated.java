/*
 * StackExchange
 * Stack Exchange is a network of 130+ Q&A communities including Stack Overflow. 
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.AccountMergeInner;
import com.konfigthis.client.model.AnswersInner;
import com.konfigthis.client.model.BadgesInner;
import com.konfigthis.client.model.CommentsInner;
import com.konfigthis.client.model.InboxItemsInner;
import com.konfigthis.client.model.NetworkUsersInner;
import com.konfigthis.client.model.NotificationsInner;
import com.konfigthis.client.model.PrivilegesInner;
import com.konfigthis.client.model.QuestionsInner;
import com.konfigthis.client.model.ReputationChangesInner;
import com.konfigthis.client.model.ReputationHistoryInner;
import com.konfigthis.client.model.SuggestedEditsInner;
import com.konfigthis.client.model.TagsInner;
import com.konfigthis.client.model.TopTagObjectsInner;
import com.konfigthis.client.model.User;
import com.konfigthis.client.model.UserTimelineObjectsInner;
import com.konfigthis.client.model.UsersInner;
import com.konfigthis.client.model.WritePermissionsInner;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class UserApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public UserApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public UserApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call getAssociatedAccountsCall(String ids, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/associated"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getAssociatedAccountsValidateBeforeCall(String ids, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getAssociatedAccounts(Async)");
        }

        return getAssociatedAccountsCall(ids, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<NetworkUsersInner>> getAssociatedAccountsWithHttpInfo(String ids, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getAssociatedAccountsValidateBeforeCall(ids, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<NetworkUsersInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getAssociatedAccountsAsync(String ids, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<NetworkUsersInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getAssociatedAccountsValidateBeforeCall(ids, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<NetworkUsersInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetAssociatedAccountsRequestBuilder {
        private final String ids;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetAssociatedAccountsRequestBuilder(String ids) {
            this.ids = ids;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetAssociatedAccountsRequestBuilder
         */
        public GetAssociatedAccountsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetAssociatedAccountsRequestBuilder
         */
        public GetAssociatedAccountsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetAssociatedAccountsRequestBuilder
         */
        public GetAssociatedAccountsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetAssociatedAccountsRequestBuilder
         */
        public GetAssociatedAccountsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getAssociatedAccounts
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getAssociatedAccountsCall(ids, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getAssociatedAccounts request
         * @return List&lt;NetworkUsersInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<NetworkUsersInner> execute() throws ApiException {
            ApiResponse<List<NetworkUsersInner>> localVarResp = getAssociatedAccountsWithHttpInfo(ids, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getAssociatedAccounts request with HTTP info returned
         * @return ApiResponse&lt;List&lt;NetworkUsersInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<NetworkUsersInner>> executeWithHttpInfo() throws ApiException {
            return getAssociatedAccountsWithHttpInfo(ids, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getAssociatedAccounts request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<NetworkUsersInner>> _callback) throws ApiException {
            return getAssociatedAccountsAsync(ids, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns all of a user&#39;s associated accounts, given their account_ids in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for account_id on user objects.   This method returns a list of network_users. 
     * @param ids Number list (semicolon delimited). (required)
     * @return GetAssociatedAccountsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetAssociatedAccountsRequestBuilder getAssociatedAccounts(String ids) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        return new GetAssociatedAccountsRequestBuilder(ids);
    }
    private okhttp3.Call getCommentsByIdsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/comments"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCommentsByIdsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getCommentsByIds(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getCommentsByIds(Async)");
        }

        return getCommentsByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> getCommentsByIdsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getCommentsByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCommentsByIdsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCommentsByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetCommentsByIdsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetCommentsByIdsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getCommentsByIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCommentsByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getCommentsByIds request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = getCommentsByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getCommentsByIds request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return getCommentsByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getCommentsByIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return getCommentsByIdsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Get the comments posted by users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetCommentsByIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetCommentsByIdsRequestBuilder getCommentsByIds(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetCommentsByIdsRequestBuilder(ids, site);
    }
    private okhttp3.Call getFavoritesListCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/favorites"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFavoritesListValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getFavoritesList(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getFavoritesList(Async)");
        }

        return getFavoritesListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<QuestionsInner>> getFavoritesListWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getFavoritesListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFavoritesListAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFavoritesListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFavoritesListRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetFavoritesListRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number sort &#x3D; added &#x3D;&gt; date  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number sort &#x3D; added &#x3D;&gt; date  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetFavoritesListRequestBuilder
         */
        public GetFavoritesListRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getFavoritesList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFavoritesListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getFavoritesList request
         * @return List&lt;QuestionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<QuestionsInner> execute() throws ApiException {
            ApiResponse<List<QuestionsInner>> localVarResp = getFavoritesListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFavoritesList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;QuestionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<QuestionsInner>> executeWithHttpInfo() throws ApiException {
            return getFavoritesListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getFavoritesList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {
            return getFavoritesListAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Get the questions that users in {ids} have favorited.   This method is effectively a view onto a user&#39;s favorites tab.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score  - added - when the user favorited the question   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetFavoritesListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetFavoritesListRequestBuilder getFavoritesList(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetFavoritesListRequestBuilder(ids, site);
    }
    private okhttp3.Call getFeaturedQuestionsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/questions/featured"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFeaturedQuestionsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getFeaturedQuestions(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getFeaturedQuestions(Async)");
        }

        return getFeaturedQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<QuestionsInner>> getFeaturedQuestionsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getFeaturedQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFeaturedQuestionsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFeaturedQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFeaturedQuestionsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetFeaturedQuestionsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetFeaturedQuestionsRequestBuilder
         */
        public GetFeaturedQuestionsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getFeaturedQuestions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFeaturedQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getFeaturedQuestions request
         * @return List&lt;QuestionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<QuestionsInner> execute() throws ApiException {
            ApiResponse<List<QuestionsInner>> localVarResp = getFeaturedQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFeaturedQuestions request with HTTP info returned
         * @return ApiResponse&lt;List&lt;QuestionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<QuestionsInner>> executeWithHttpInfo() throws ApiException {
            return getFeaturedQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getFeaturedQuestions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {
            return getFeaturedQuestionsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the questions on which the users in {ids} have active bounties.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetFeaturedQuestionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetFeaturedQuestionsRequestBuilder getFeaturedQuestions(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetFeaturedQuestionsRequestBuilder(ids, site);
    }
    private okhttp3.Call getFullReputationHistoryCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/reputation-history/full"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFullReputationHistoryValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getFullReputationHistory(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getFullReputationHistory(Async)");
        }

        return getFullReputationHistoryCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<ReputationHistoryInner>> getFullReputationHistoryWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getFullReputationHistoryValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<ReputationHistoryInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getFullReputationHistoryAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<ReputationHistoryInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getFullReputationHistoryValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<ReputationHistoryInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetFullReputationHistoryRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetFullReputationHistoryRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetFullReputationHistoryRequestBuilder
         */
        public GetFullReputationHistoryRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetFullReputationHistoryRequestBuilder
         */
        public GetFullReputationHistoryRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetFullReputationHistoryRequestBuilder
         */
        public GetFullReputationHistoryRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetFullReputationHistoryRequestBuilder
         */
        public GetFullReputationHistoryRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getFullReputationHistory
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getFullReputationHistoryCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getFullReputationHistory request
         * @return List&lt;ReputationHistoryInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<ReputationHistoryInner> execute() throws ApiException {
            ApiResponse<List<ReputationHistoryInner>> localVarResp = getFullReputationHistoryWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getFullReputationHistory request with HTTP info returned
         * @return ApiResponse&lt;List&lt;ReputationHistoryInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<ReputationHistoryInner>> executeWithHttpInfo() throws ApiException {
            return getFullReputationHistoryWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getFullReputationHistory request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<ReputationHistoryInner>> _callback) throws ApiException {
            return getFullReputationHistoryAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a user&#39;s full reputation history, including private events.   This method requires an access_token, with a scope containing \&quot;private_info\&quot;.   This method returns a list of reputation_history. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetFullReputationHistoryRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetFullReputationHistoryRequestBuilder getFullReputationHistory(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetFullReputationHistoryRequestBuilder(id, site);
    }
    private okhttp3.Call getInboxItemsCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/inbox"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getInboxItemsValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getInboxItems(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getInboxItems(Async)");
        }

        return getInboxItemsCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<InboxItemsInner>> getInboxItemsWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getInboxItemsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<InboxItemsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getInboxItemsAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<InboxItemsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getInboxItemsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<InboxItemsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetInboxItemsRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetInboxItemsRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetInboxItemsRequestBuilder
         */
        public GetInboxItemsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetInboxItemsRequestBuilder
         */
        public GetInboxItemsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetInboxItemsRequestBuilder
         */
        public GetInboxItemsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetInboxItemsRequestBuilder
         */
        public GetInboxItemsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getInboxItems
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getInboxItemsCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getInboxItems request
         * @return List&lt;InboxItemsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<InboxItemsInner> execute() throws ApiException {
            ApiResponse<List<InboxItemsInner>> localVarResp = getInboxItemsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getInboxItems request with HTTP info returned
         * @return ApiResponse&lt;List&lt;InboxItemsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<InboxItemsInner>> executeWithHttpInfo() throws ApiException {
            return getInboxItemsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getInboxItems request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<InboxItemsInner>> _callback) throws ApiException {
            return getInboxItemsAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a user&#39;s inbox.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method is effectively an alias for /inbox. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetInboxItemsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetInboxItemsRequestBuilder getInboxItems(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetInboxItemsRequestBuilder(id, site);
    }
    private okhttp3.Call getInboxUnreadCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, Integer since, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/inbox/unread"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        if (since != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("since", since));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getInboxUnreadValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, Integer since, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getInboxUnread(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getInboxUnread(Async)");
        }

        return getInboxUnreadCall(id, site, pagesize, page, filter, paramCallback, since, _callback);

    }


    private ApiResponse<List<InboxItemsInner>> getInboxUnreadWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, Integer since) throws ApiException {
        okhttp3.Call localVarCall = getInboxUnreadValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, since, null);
        Type localVarReturnType = new TypeToken<List<InboxItemsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getInboxUnreadAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, Integer since, final ApiCallback<List<InboxItemsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getInboxUnreadValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, since, _callback);
        Type localVarReturnType = new TypeToken<List<InboxItemsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetInboxUnreadRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;
        private Integer since;

        private GetInboxUnreadRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetInboxUnreadRequestBuilder
         */
        public GetInboxUnreadRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetInboxUnreadRequestBuilder
         */
        public GetInboxUnreadRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetInboxUnreadRequestBuilder
         */
        public GetInboxUnreadRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetInboxUnreadRequestBuilder
         */
        public GetInboxUnreadRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Set since
         * @param since Unix date. (optional)
         * @return GetInboxUnreadRequestBuilder
         */
        public GetInboxUnreadRequestBuilder since(Integer since) {
            this.since = since;
            return this;
        }
        
        /**
         * Build call for getInboxUnread
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getInboxUnreadCall(id, site, pagesize, page, filter, paramCallback, since, _callback);
        }


        /**
         * Execute getInboxUnread request
         * @return List&lt;InboxItemsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<InboxItemsInner> execute() throws ApiException {
            ApiResponse<List<InboxItemsInner>> localVarResp = getInboxUnreadWithHttpInfo(id, site, pagesize, page, filter, paramCallback, since);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getInboxUnread request with HTTP info returned
         * @return ApiResponse&lt;List&lt;InboxItemsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<InboxItemsInner>> executeWithHttpInfo() throws ApiException {
            return getInboxUnreadWithHttpInfo(id, site, pagesize, page, filter, paramCallback, since);
        }

        /**
         * Execute getInboxUnread request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<InboxItemsInner>> _callback) throws ApiException {
            return getInboxUnreadAsync(id, site, pagesize, page, filter, paramCallback, since, _callback);
        }
    }

    /**
     * 
     * Returns the unread items in a user&#39;s inbox.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method is effectively an alias for /inbox/unread. It is provided for consumers who make strong assumptions about operating within the context of a single site rather than the Stack Exchange network as a whole.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of inbox items. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetInboxUnreadRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetInboxUnreadRequestBuilder getInboxUnread(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetInboxUnreadRequestBuilder(id, site);
    }
    private okhttp3.Call getNotificationsListCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/notifications"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getNotificationsListValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getNotificationsList(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getNotificationsList(Async)");
        }

        return getNotificationsListCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<NotificationsInner>> getNotificationsListWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getNotificationsListValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<NotificationsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getNotificationsListAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<NotificationsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getNotificationsListValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<NotificationsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetNotificationsListRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetNotificationsListRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetNotificationsListRequestBuilder
         */
        public GetNotificationsListRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetNotificationsListRequestBuilder
         */
        public GetNotificationsListRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetNotificationsListRequestBuilder
         */
        public GetNotificationsListRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetNotificationsListRequestBuilder
         */
        public GetNotificationsListRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getNotificationsList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getNotificationsListCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getNotificationsList request
         * @return List&lt;NotificationsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<NotificationsInner> execute() throws ApiException {
            ApiResponse<List<NotificationsInner>> localVarResp = getNotificationsListWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getNotificationsList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;NotificationsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<NotificationsInner>> executeWithHttpInfo() throws ApiException {
            return getNotificationsListWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getNotificationsList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<NotificationsInner>> _callback) throws ApiException {
            return getNotificationsListAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a user&#39;s notifications.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method returns a list of notifications. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetNotificationsListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetNotificationsListRequestBuilder getNotificationsList(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetNotificationsListRequestBuilder(id, site);
    }
    private okhttp3.Call getPrivilegesListCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/privileges"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getPrivilegesListValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getPrivilegesList(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getPrivilegesList(Async)");
        }

        return getPrivilegesListCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<PrivilegesInner>> getPrivilegesListWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getPrivilegesListValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<PrivilegesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getPrivilegesListAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<PrivilegesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getPrivilegesListValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<PrivilegesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetPrivilegesListRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetPrivilegesListRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetPrivilegesListRequestBuilder
         */
        public GetPrivilegesListRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetPrivilegesListRequestBuilder
         */
        public GetPrivilegesListRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetPrivilegesListRequestBuilder
         */
        public GetPrivilegesListRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetPrivilegesListRequestBuilder
         */
        public GetPrivilegesListRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getPrivilegesList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getPrivilegesListCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getPrivilegesList request
         * @return List&lt;PrivilegesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<PrivilegesInner> execute() throws ApiException {
            ApiResponse<List<PrivilegesInner>> localVarResp = getPrivilegesListWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getPrivilegesList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;PrivilegesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<PrivilegesInner>> executeWithHttpInfo() throws ApiException {
            return getPrivilegesListWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getPrivilegesList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<PrivilegesInner>> _callback) throws ApiException {
            return getPrivilegesListAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the privileges a user has.   Applications are encouraged to calculate privileges themselves, without repeated queries to this method. A simple check against the results returned by /privileges and user.user_type would be sufficient.   {id} can contain only a single, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of privileges. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetPrivilegesListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetPrivilegesListRequestBuilder getPrivilegesList(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetPrivilegesListRequestBuilder(id, site);
    }
    private okhttp3.Call getQuestionsByUserIdsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/questions"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getQuestionsByUserIdsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getQuestionsByUserIds(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getQuestionsByUserIds(Async)");
        }

        return getQuestionsByUserIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<QuestionsInner>> getQuestionsByUserIdsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getQuestionsByUserIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getQuestionsByUserIdsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getQuestionsByUserIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetQuestionsByUserIdsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetQuestionsByUserIdsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetQuestionsByUserIdsRequestBuilder
         */
        public GetQuestionsByUserIdsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getQuestionsByUserIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getQuestionsByUserIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getQuestionsByUserIds request
         * @return List&lt;QuestionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<QuestionsInner> execute() throws ApiException {
            ApiResponse<List<QuestionsInner>> localVarResp = getQuestionsByUserIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getQuestionsByUserIds request with HTTP info returned
         * @return ApiResponse&lt;List&lt;QuestionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<QuestionsInner>> executeWithHttpInfo() throws ApiException {
            return getQuestionsByUserIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getQuestionsByUserIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {
            return getQuestionsByUserIdsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the questions asked by the users in {ids}.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetQuestionsByUserIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetQuestionsByUserIdsRequestBuilder getQuestionsByUserIds(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetQuestionsByUserIdsRequestBuilder(ids, site);
    }
    private okhttp3.Call getReputationChangesCall(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/reputation"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReputationChangesValidateBeforeCall(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getReputationChanges(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getReputationChanges(Async)");
        }

        return getReputationChangesCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<ReputationChangesInner>> getReputationChangesWithHttpInfo(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getReputationChangesValidateBeforeCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<ReputationChangesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getReputationChangesAsync(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<ReputationChangesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReputationChangesValidateBeforeCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<ReputationChangesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetReputationChangesRequestBuilder {
        private final String ids;
        private final String site;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetReputationChangesRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetReputationChangesRequestBuilder
         */
        public GetReputationChangesRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetReputationChangesRequestBuilder
         */
        public GetReputationChangesRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetReputationChangesRequestBuilder
         */
        public GetReputationChangesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetReputationChangesRequestBuilder
         */
        public GetReputationChangesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetReputationChangesRequestBuilder
         */
        public GetReputationChangesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetReputationChangesRequestBuilder
         */
        public GetReputationChangesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getReputationChanges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getReputationChangesCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getReputationChanges request
         * @return List&lt;ReputationChangesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<ReputationChangesInner> execute() throws ApiException {
            ApiResponse<List<ReputationChangesInner>> localVarResp = getReputationChangesWithHttpInfo(ids, site, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getReputationChanges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;ReputationChangesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<ReputationChangesInner>> executeWithHttpInfo() throws ApiException {
            return getReputationChangesWithHttpInfo(ids, site, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getReputationChanges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<ReputationChangesInner>> _callback) throws ApiException {
            return getReputationChangesAsync(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets a subset of the reputation changes for users in {ids}.   Reputation changes are intentionally scrubbed of some data to make it difficult to correlate votes on particular posts with user reputation changes. That being said, this method returns enough data for reasonable display of reputation trends.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of reputation objects. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetReputationChangesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetReputationChangesRequestBuilder getReputationChanges(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetReputationChangesRequestBuilder(ids, site);
    }
    private okhttp3.Call getReputationHistoryCall(String ids, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/reputation-history"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReputationHistoryValidateBeforeCall(String ids, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getReputationHistory(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getReputationHistory(Async)");
        }

        return getReputationHistoryCall(ids, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<ReputationHistoryInner>> getReputationHistoryWithHttpInfo(String ids, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getReputationHistoryValidateBeforeCall(ids, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<ReputationHistoryInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getReputationHistoryAsync(String ids, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<ReputationHistoryInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReputationHistoryValidateBeforeCall(ids, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<ReputationHistoryInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetReputationHistoryRequestBuilder {
        private final String ids;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetReputationHistoryRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetReputationHistoryRequestBuilder
         */
        public GetReputationHistoryRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetReputationHistoryRequestBuilder
         */
        public GetReputationHistoryRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetReputationHistoryRequestBuilder
         */
        public GetReputationHistoryRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetReputationHistoryRequestBuilder
         */
        public GetReputationHistoryRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getReputationHistory
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getReputationHistoryCall(ids, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getReputationHistory request
         * @return List&lt;ReputationHistoryInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<ReputationHistoryInner> execute() throws ApiException {
            ApiResponse<List<ReputationHistoryInner>> localVarResp = getReputationHistoryWithHttpInfo(ids, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getReputationHistory request with HTTP info returned
         * @return ApiResponse&lt;List&lt;ReputationHistoryInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<ReputationHistoryInner>> executeWithHttpInfo() throws ApiException {
            return getReputationHistoryWithHttpInfo(ids, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getReputationHistory request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<ReputationHistoryInner>> _callback) throws ApiException {
            return getReputationHistoryAsync(ids, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns users&#39; public reputation history.   This method returns a list of reputation_history. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetReputationHistoryRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetReputationHistoryRequestBuilder getReputationHistory(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetReputationHistoryRequestBuilder(ids, site);
    }
    private okhttp3.Call getSuggestedEditsByIdsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/suggested-edits"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSuggestedEditsByIdsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getSuggestedEditsByIds(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getSuggestedEditsByIds(Async)");
        }

        return getSuggestedEditsByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<SuggestedEditsInner>> getSuggestedEditsByIdsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getSuggestedEditsByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<SuggestedEditsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getSuggestedEditsByIdsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<SuggestedEditsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getSuggestedEditsByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<SuggestedEditsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetSuggestedEditsByIdsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetSuggestedEditsByIdsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; approval &#x3D;&gt; date sort &#x3D; rejection &#x3D;&gt; date  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; approval &#x3D;&gt; date sort &#x3D; rejection &#x3D;&gt; date  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetSuggestedEditsByIdsRequestBuilder
         */
        public GetSuggestedEditsByIdsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getSuggestedEditsByIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getSuggestedEditsByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getSuggestedEditsByIds request
         * @return List&lt;SuggestedEditsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<SuggestedEditsInner> execute() throws ApiException {
            ApiResponse<List<SuggestedEditsInner>> localVarResp = getSuggestedEditsByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getSuggestedEditsByIds request with HTTP info returned
         * @return ApiResponse&lt;List&lt;SuggestedEditsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<SuggestedEditsInner>> executeWithHttpInfo() throws ApiException {
            return getSuggestedEditsByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getSuggestedEditsByIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<SuggestedEditsInner>> _callback) throws ApiException {
            return getSuggestedEditsByIdsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the suggested edits a users in {ids} have submitted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the suggested_edit object:  - creation - creation_date  - approval - approval_date Does not return unapproved suggested_edits  - rejection - rejection_date Does not return unrejected suggested_edits   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of suggested-edits. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetSuggestedEditsByIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetSuggestedEditsByIdsRequestBuilder getSuggestedEditsByIds(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetSuggestedEditsByIdsRequestBuilder(ids, site);
    }
    private okhttp3.Call getTagsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/tags"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTagsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getTags(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getTags(Async)");
        }

        return getTagsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<TagsInner>> getTagsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getTagsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<TagsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getTagsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<TagsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTagsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<TagsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetTagsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetTagsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; popular &#x3D;&gt; number sort &#x3D; activity &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetTagsRequestBuilder
         */
        public GetTagsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getTagsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getTags request
         * @return List&lt;TagsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<TagsInner> execute() throws ApiException {
            ApiResponse<List<TagsInner>> localVarResp = getTagsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getTags request with HTTP info returned
         * @return ApiResponse&lt;List&lt;TagsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<TagsInner>> executeWithHttpInfo() throws ApiException {
            return getTagsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<TagsInner>> _callback) throws ApiException {
            return getTagsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the tags the users identified in {ids} have been active in.   This route corresponds roughly to user&#39;s stats tab, but does not include tag scores. A subset of tag scores are available (on a single user basis) in /users/{id}/top-answer-tags and /users/{id}/top-question-tags.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the tag object:  - popular - count  - activity - the creation_date of the last question asked with the tag  - name - name   popular is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of tags. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetTagsRequestBuilder getTags(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetTagsRequestBuilder(ids, site);
    }
    private okhttp3.Call getTopQuestionTagsCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/top-question-tags"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTopQuestionTagsValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getTopQuestionTags(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getTopQuestionTags(Async)");
        }

        return getTopQuestionTagsCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<TopTagObjectsInner>> getTopQuestionTagsWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getTopQuestionTagsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<TopTagObjectsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getTopQuestionTagsAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<TopTagObjectsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTopQuestionTagsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<TopTagObjectsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetTopQuestionTagsRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetTopQuestionTagsRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetTopQuestionTagsRequestBuilder
         */
        public GetTopQuestionTagsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetTopQuestionTagsRequestBuilder
         */
        public GetTopQuestionTagsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetTopQuestionTagsRequestBuilder
         */
        public GetTopQuestionTagsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetTopQuestionTagsRequestBuilder
         */
        public GetTopQuestionTagsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getTopQuestionTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getTopQuestionTagsCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getTopQuestionTags request
         * @return List&lt;TopTagObjectsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<TopTagObjectsInner> execute() throws ApiException {
            ApiResponse<List<TopTagObjectsInner>> localVarResp = getTopQuestionTagsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getTopQuestionTags request with HTTP info returned
         * @return ApiResponse&lt;List&lt;TopTagObjectsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<TopTagObjectsInner>> executeWithHttpInfo() throws ApiException {
            return getTopQuestionTagsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getTopQuestionTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<TopTagObjectsInner>> _callback) throws ApiException {
            return getTopQuestionTagsAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a single user&#39;s top tags by question score.   This a subset of the data returned on a user&#39;s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetTopQuestionTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetTopQuestionTagsRequestBuilder getTopQuestionTags(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetTopQuestionTagsRequestBuilder(id, site);
    }
    private okhttp3.Call getTopQuestionsByTagsCall(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/tags/{tags}/top-questions"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()))
            .replace("{" + "tags" + "}", localVarApiClient.escapeString(tags.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getTopQuestionsByTagsValidateBeforeCall(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getTopQuestionsByTags(Async)");
        }

        // verify the required parameter 'tags' is set
        if (tags == null) {
            throw new ApiException("Missing the required parameter 'tags' when calling getTopQuestionsByTags(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getTopQuestionsByTags(Async)");
        }

        return getTopQuestionsByTagsCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<QuestionsInner>> getTopQuestionsByTagsWithHttpInfo(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getTopQuestionsByTagsValidateBeforeCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getTopQuestionsByTagsAsync(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getTopQuestionsByTagsValidateBeforeCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetTopQuestionsByTagsRequestBuilder {
        private final Integer id;
        private final String tags;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetTopQuestionsByTagsRequestBuilder(Integer id, String tags, String site) {
            this.id = id;
            this.tags = tags;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetTopQuestionsByTagsRequestBuilder
         */
        public GetTopQuestionsByTagsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getTopQuestionsByTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getTopQuestionsByTagsCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getTopQuestionsByTags request
         * @return List&lt;QuestionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<QuestionsInner> execute() throws ApiException {
            ApiResponse<List<QuestionsInner>> localVarResp = getTopQuestionsByTagsWithHttpInfo(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getTopQuestionsByTags request with HTTP info returned
         * @return ApiResponse&lt;List&lt;QuestionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<QuestionsInner>> executeWithHttpInfo() throws ApiException {
            return getTopQuestionsByTagsWithHttpInfo(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getTopQuestionsByTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {
            return getTopQuestionsByTagsAsync(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the top 30 questions a user has asked with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param id  (required)
     * @param tags String list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetTopQuestionsByTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetTopQuestionsByTagsRequestBuilder getTopQuestionsByTags(Integer id, String tags, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (tags == null) throw new IllegalArgumentException("\"tags\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetTopQuestionsByTagsRequestBuilder(id, tags, site);
    }
    private okhttp3.Call getUnacceptedQuestionsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/questions/unaccepted"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUnacceptedQuestionsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getUnacceptedQuestions(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUnacceptedQuestions(Async)");
        }

        return getUnacceptedQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<QuestionsInner>> getUnacceptedQuestionsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUnacceptedQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUnacceptedQuestionsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUnacceptedQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUnacceptedQuestionsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUnacceptedQuestionsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUnacceptedQuestionsRequestBuilder
         */
        public GetUnacceptedQuestionsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUnacceptedQuestions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUnacceptedQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUnacceptedQuestions request
         * @return List&lt;QuestionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<QuestionsInner> execute() throws ApiException {
            ApiResponse<List<QuestionsInner>> localVarResp = getUnacceptedQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUnacceptedQuestions request with HTTP info returned
         * @return ApiResponse&lt;List&lt;QuestionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<QuestionsInner>> executeWithHttpInfo() throws ApiException {
            return getUnacceptedQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUnacceptedQuestions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {
            return getUnacceptedQuestionsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the questions asked by the users in {ids} which have at least one answer, but no accepted answer.   Questions returned by this method have answers, but the owner has not opted to accept any of them.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUnacceptedQuestionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUnacceptedQuestionsRequestBuilder getUnacceptedQuestions(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUnacceptedQuestionsRequestBuilder(ids, site);
    }
    private okhttp3.Call getUnansweredQuestionsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/questions/unanswered"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUnansweredQuestionsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getUnansweredQuestions(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUnansweredQuestions(Async)");
        }

        return getUnansweredQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<QuestionsInner>> getUnansweredQuestionsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUnansweredQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUnansweredQuestionsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUnansweredQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUnansweredQuestionsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUnansweredQuestionsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUnansweredQuestionsRequestBuilder
         */
        public GetUnansweredQuestionsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUnansweredQuestions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUnansweredQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUnansweredQuestions request
         * @return List&lt;QuestionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<QuestionsInner> execute() throws ApiException {
            ApiResponse<List<QuestionsInner>> localVarResp = getUnansweredQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUnansweredQuestions request with HTTP info returned
         * @return ApiResponse&lt;List&lt;QuestionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<QuestionsInner>> executeWithHttpInfo() throws ApiException {
            return getUnansweredQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUnansweredQuestions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {
            return getUnansweredQuestionsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the questions asked by the users in {ids} which the site consideres unanswered, while still having at least one answer posted.   These rules are subject to change, but currently any question without at least one upvoted or accepted answer is considered unanswered.   To get the set of questions that a user probably considers unanswered, the returned questions should be unioned with those returned by /users/{id}/questions/no-answers. These methods are distinct so that truly unanswered (that is, zero posted answers) questions can be easily separated from mearly poorly or inadequately answered ones.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUnansweredQuestionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUnansweredQuestionsRequestBuilder getUnansweredQuestions(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUnansweredQuestionsRequestBuilder(ids, site);
    }
    private okhttp3.Call getUnreadNotificationsCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/notifications/unread"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUnreadNotificationsValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getUnreadNotifications(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUnreadNotifications(Async)");
        }

        return getUnreadNotificationsCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<NotificationsInner>> getUnreadNotificationsWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUnreadNotificationsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<NotificationsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUnreadNotificationsAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<NotificationsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUnreadNotificationsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<NotificationsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUnreadNotificationsRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUnreadNotificationsRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUnreadNotificationsRequestBuilder
         */
        public GetUnreadNotificationsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUnreadNotificationsRequestBuilder
         */
        public GetUnreadNotificationsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUnreadNotificationsRequestBuilder
         */
        public GetUnreadNotificationsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUnreadNotificationsRequestBuilder
         */
        public GetUnreadNotificationsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUnreadNotifications
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUnreadNotificationsCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUnreadNotifications request
         * @return List&lt;NotificationsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<NotificationsInner> execute() throws ApiException {
            ApiResponse<List<NotificationsInner>> localVarResp = getUnreadNotificationsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUnreadNotifications request with HTTP info returned
         * @return ApiResponse&lt;List&lt;NotificationsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<NotificationsInner>> executeWithHttpInfo() throws ApiException {
            return getUnreadNotificationsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUnreadNotifications request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<NotificationsInner>> _callback) throws ApiException {
            return getUnreadNotificationsAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a user&#39;s unread notifications.   This method requires an access_token, with a scope containing \&quot;read_inbox\&quot;.   This method returns a list of notifications. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUnreadNotificationsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUnreadNotificationsRequestBuilder getUnreadNotifications(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUnreadNotificationsRequestBuilder(id, site);
    }
    private okhttp3.Call getUserCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/me";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserValidateBeforeCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUser(Async)");
        }

        return getUserCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<User> getUserWithHttpInfo(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<User>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserAsync(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<User> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<User>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserRequestBuilder {
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserRequestBuilder
         */
        public GetUserRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUser
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUser request
         * @return User
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public User execute() throws ApiException {
            ApiResponse<User> localVarResp = getUserWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUser request with HTTP info returned
         * @return ApiResponse&lt;User&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<User> executeWithHttpInfo() throws ApiException {
            return getUserWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUser request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<User> _callback) throws ApiException {
            return getUserAsync(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the user associated with the passed access_token.   This method returns a user. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserRequestBuilder getUser(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserRequestBuilder(site);
    }
    private okhttp3.Call getUserAnswersListCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/answers"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserAnswersListValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getUserAnswersList(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUserAnswersList(Async)");
        }

        return getUserAnswersListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<AnswersInner>> getUserAnswersListWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserAnswersListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<AnswersInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserAnswersListAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<AnswersInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserAnswersListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<AnswersInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserAnswersListRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserAnswersListRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserAnswersListRequestBuilder
         */
        public GetUserAnswersListRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUserAnswersList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserAnswersListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUserAnswersList request
         * @return List&lt;AnswersInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<AnswersInner> execute() throws ApiException {
            ApiResponse<List<AnswersInner>> localVarResp = getUserAnswersListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserAnswersList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;AnswersInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<AnswersInner>> executeWithHttpInfo() throws ApiException {
            return getUserAnswersListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUserAnswersList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<AnswersInner>> _callback) throws ApiException {
            return getUserAnswersListAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the answers the users in {ids} have posted.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserAnswersListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserAnswersListRequestBuilder getUserAnswersList(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserAnswersListRequestBuilder(ids, site);
    }
    private okhttp3.Call getUserCommentsByIdsAndToidCall(String ids, Integer toid, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/comments/{toid}"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()))
            .replace("{" + "toid" + "}", localVarApiClient.escapeString(toid.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserCommentsByIdsAndToidValidateBeforeCall(String ids, Integer toid, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getUserCommentsByIdsAndToid(Async)");
        }

        // verify the required parameter 'toid' is set
        if (toid == null) {
            throw new ApiException("Missing the required parameter 'toid' when calling getUserCommentsByIdsAndToid(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUserCommentsByIdsAndToid(Async)");
        }

        return getUserCommentsByIdsAndToidCall(ids, toid, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> getUserCommentsByIdsAndToidWithHttpInfo(String ids, Integer toid, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserCommentsByIdsAndToidValidateBeforeCall(ids, toid, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserCommentsByIdsAndToidAsync(String ids, Integer toid, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserCommentsByIdsAndToidValidateBeforeCall(ids, toid, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserCommentsByIdsAndToidRequestBuilder {
        private final String ids;
        private final Integer toid;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserCommentsByIdsAndToidRequestBuilder(String ids, Integer toid, String site) {
            this.ids = ids;
            this.toid = toid;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserCommentsByIdsAndToidRequestBuilder
         */
        public GetUserCommentsByIdsAndToidRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUserCommentsByIdsAndToid
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserCommentsByIdsAndToidCall(ids, toid, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUserCommentsByIdsAndToid request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = getUserCommentsByIdsAndToidWithHttpInfo(ids, toid, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserCommentsByIdsAndToid request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return getUserCommentsByIdsAndToidWithHttpInfo(ids, toid, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUserCommentsByIdsAndToid request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return getUserCommentsByIdsAndToidAsync(ids, toid, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Get the comments that the users in {ids} have posted in reply to the single user identified in {toid}.   This method is useful for extracting conversations, especially over time or across multiple posts.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects. {toid} can contain only 1 id, found in the same manner as those in {ids}.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param ids Number list (semicolon delimited). (required)
     * @param toid  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserCommentsByIdsAndToidRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserCommentsByIdsAndToidRequestBuilder getUserCommentsByIdsAndToid(String ids, Integer toid, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (toid == null) throw new IllegalArgumentException("\"toid\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserCommentsByIdsAndToidRequestBuilder(ids, toid, site);
    }
    private okhttp3.Call getUserProfilesByIdsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserProfilesByIdsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getUserProfilesByIds(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUserProfilesByIds(Async)");
        }

        return getUserProfilesByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<UsersInner>> getUserProfilesByIdsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserProfilesByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserProfilesByIdsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<UsersInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserProfilesByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserProfilesByIdsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserProfilesByIdsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserProfilesByIdsRequestBuilder
         */
        public GetUserProfilesByIdsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUserProfilesByIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserProfilesByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUserProfilesByIds request
         * @return List&lt;UsersInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<UsersInner> execute() throws ApiException {
            ApiResponse<List<UsersInner>> localVarResp = getUserProfilesByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserProfilesByIds request with HTTP info returned
         * @return ApiResponse&lt;List&lt;UsersInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<UsersInner>> executeWithHttpInfo() throws ApiException {
            return getUserProfilesByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUserProfilesByIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<UsersInner>> _callback) throws ApiException {
            return getUserProfilesByIdsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the users identified in ids in {ids}.   Typically this method will be called to fetch user profiles when you have obtained user ids from some other source, such as /questions.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserProfilesByIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserProfilesByIdsRequestBuilder getUserProfilesByIds(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserProfilesByIdsRequestBuilder(ids, site);
    }
    private okhttp3.Call getUserTimelineByIdsCall(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/timeline"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserTimelineByIdsValidateBeforeCall(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getUserTimelineByIds(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUserTimelineByIds(Async)");
        }

        return getUserTimelineByIdsCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<UserTimelineObjectsInner>> getUserTimelineByIdsWithHttpInfo(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserTimelineByIdsValidateBeforeCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<UserTimelineObjectsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserTimelineByIdsAsync(String ids, String site, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<UserTimelineObjectsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserTimelineByIdsValidateBeforeCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<UserTimelineObjectsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserTimelineByIdsRequestBuilder {
        private final String ids;
        private final String site;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserTimelineByIdsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUserTimelineByIdsRequestBuilder
         */
        public GetUserTimelineByIdsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUserTimelineByIdsRequestBuilder
         */
        public GetUserTimelineByIdsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserTimelineByIdsRequestBuilder
         */
        public GetUserTimelineByIdsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserTimelineByIdsRequestBuilder
         */
        public GetUserTimelineByIdsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserTimelineByIdsRequestBuilder
         */
        public GetUserTimelineByIdsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserTimelineByIdsRequestBuilder
         */
        public GetUserTimelineByIdsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUserTimelineByIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserTimelineByIdsCall(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUserTimelineByIds request
         * @return List&lt;UserTimelineObjectsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<UserTimelineObjectsInner> execute() throws ApiException {
            ApiResponse<List<UserTimelineObjectsInner>> localVarResp = getUserTimelineByIdsWithHttpInfo(ids, site, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserTimelineByIds request with HTTP info returned
         * @return ApiResponse&lt;List&lt;UserTimelineObjectsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<UserTimelineObjectsInner>> executeWithHttpInfo() throws ApiException {
            return getUserTimelineByIdsWithHttpInfo(ids, site, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUserTimelineByIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<UserTimelineObjectsInner>> _callback) throws ApiException {
            return getUserTimelineByIdsAsync(ids, site, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a subset of the actions the users in {ids} have taken on the site.   This method returns users&#39; posts, edits, and earned badges in the order they were accomplished. It is possible to filter to just a window of activity using the fromdate and todate parameters.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of user timeline objects. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserTimelineByIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserTimelineByIdsRequestBuilder getUserTimelineByIds(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserTimelineByIdsRequestBuilder(ids, site);
    }
    private okhttp3.Call getUserTopAnswerTagsCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/top-answer-tags"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserTopAnswerTagsValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getUserTopAnswerTags(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUserTopAnswerTags(Async)");
        }

        return getUserTopAnswerTagsCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<TopTagObjectsInner>> getUserTopAnswerTagsWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserTopAnswerTagsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<TopTagObjectsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserTopAnswerTagsAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<TopTagObjectsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserTopAnswerTagsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<TopTagObjectsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserTopAnswerTagsRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserTopAnswerTagsRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserTopAnswerTagsRequestBuilder
         */
        public GetUserTopAnswerTagsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserTopAnswerTagsRequestBuilder
         */
        public GetUserTopAnswerTagsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserTopAnswerTagsRequestBuilder
         */
        public GetUserTopAnswerTagsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserTopAnswerTagsRequestBuilder
         */
        public GetUserTopAnswerTagsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUserTopAnswerTags
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserTopAnswerTagsCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUserTopAnswerTags request
         * @return List&lt;TopTagObjectsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<TopTagObjectsInner> execute() throws ApiException {
            ApiResponse<List<TopTagObjectsInner>> localVarResp = getUserTopAnswerTagsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserTopAnswerTags request with HTTP info returned
         * @return ApiResponse&lt;List&lt;TopTagObjectsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<TopTagObjectsInner>> executeWithHttpInfo() throws ApiException {
            return getUserTopAnswerTagsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUserTopAnswerTags request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<TopTagObjectsInner>> _callback) throws ApiException {
            return getUserTopAnswerTagsAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a single user&#39;s top tags by answer score.   This a subset of the data returned on a user&#39;s tags tab.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects.   This method returns a list of top_tag objects. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserTopAnswerTagsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserTopAnswerTagsRequestBuilder getUserTopAnswerTags(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserTopAnswerTagsRequestBuilder(id, site);
    }
    private okhttp3.Call getUserTopAnswersCall(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/tags/{tags}/top-answers"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()))
            .replace("{" + "tags" + "}", localVarApiClient.escapeString(tags.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getUserTopAnswersValidateBeforeCall(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getUserTopAnswers(Async)");
        }

        // verify the required parameter 'tags' is set
        if (tags == null) {
            throw new ApiException("Missing the required parameter 'tags' when calling getUserTopAnswers(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getUserTopAnswers(Async)");
        }

        return getUserTopAnswersCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<AnswersInner>> getUserTopAnswersWithHttpInfo(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getUserTopAnswersValidateBeforeCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<AnswersInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getUserTopAnswersAsync(Integer id, String tags, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<AnswersInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getUserTopAnswersValidateBeforeCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<AnswersInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetUserTopAnswersRequestBuilder {
        private final Integer id;
        private final String tags;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetUserTopAnswersRequestBuilder(Integer id, String tags, String site) {
            this.id = id;
            this.tags = tags;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetUserTopAnswersRequestBuilder
         */
        public GetUserTopAnswersRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getUserTopAnswers
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getUserTopAnswersCall(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getUserTopAnswers request
         * @return List&lt;AnswersInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<AnswersInner> execute() throws ApiException {
            ApiResponse<List<AnswersInner>> localVarResp = getUserTopAnswersWithHttpInfo(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getUserTopAnswers request with HTTP info returned
         * @return ApiResponse&lt;List&lt;AnswersInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<AnswersInner>> executeWithHttpInfo() throws ApiException {
            return getUserTopAnswersWithHttpInfo(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getUserTopAnswers request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<AnswersInner>> _callback) throws ApiException {
            return getUserTopAnswersAsync(id, tags, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the top 30 answers a user has posted in response to questions with the given tags.   {id} can contain a single id, to find it programatically look for user_id on user or shallow_user objects. {tags} is limited to 5 tags, passing more will result in an error.   The sorts accepted by this method operate on the follow fields of the answer object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of answers. 
     * @param id  (required)
     * @param tags String list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetUserTopAnswersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetUserTopAnswersRequestBuilder getUserTopAnswers(Integer id, String tags, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (tags == null) throw new IllegalArgumentException("\"tags\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetUserTopAnswersRequestBuilder(id, tags, site);
    }
    private okhttp3.Call getWritePermissionsCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{id}/write-permissions"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getWritePermissionsValidateBeforeCall(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getWritePermissions(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getWritePermissions(Async)");
        }

        return getWritePermissionsCall(id, site, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<WritePermissionsInner>> getWritePermissionsWithHttpInfo(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getWritePermissionsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<WritePermissionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getWritePermissionsAsync(Integer id, String site, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<WritePermissionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getWritePermissionsValidateBeforeCall(id, site, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<WritePermissionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetWritePermissionsRequestBuilder {
        private final Integer id;
        private final String site;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetWritePermissionsRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetWritePermissionsRequestBuilder
         */
        public GetWritePermissionsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetWritePermissionsRequestBuilder
         */
        public GetWritePermissionsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetWritePermissionsRequestBuilder
         */
        public GetWritePermissionsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetWritePermissionsRequestBuilder
         */
        public GetWritePermissionsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getWritePermissions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getWritePermissionsCall(id, site, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getWritePermissions request
         * @return List&lt;WritePermissionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<WritePermissionsInner> execute() throws ApiException {
            ApiResponse<List<WritePermissionsInner>> localVarResp = getWritePermissionsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getWritePermissions request with HTTP info returned
         * @return ApiResponse&lt;List&lt;WritePermissionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<WritePermissionsInner>> executeWithHttpInfo() throws ApiException {
            return getWritePermissionsWithHttpInfo(id, site, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getWritePermissions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<WritePermissionsInner>> _callback) throws ApiException {
            return getWritePermissionsAsync(id, site, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the write permissions a user has via the api.   The Stack Exchange API gives users the ability to create, edit, and delete certain types. This method returns whether the passed user is capable of performing those actions at all, as well as how many times a day they can.   This method does not consider the user&#39;s current quota (ie. if they&#39;ve already exhausted it for today) nor any additional restrictions on write access, such as editing deleted comments.   This method returns a list of write_permissions. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetWritePermissionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetWritePermissionsRequestBuilder getWritePermissions(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetWritePermissionsRequestBuilder(id, site);
    }
    private okhttp3.Call listAccountMergesCall(String ids, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/merges"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listAccountMergesValidateBeforeCall(String ids, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling listAccountMerges(Async)");
        }

        return listAccountMergesCall(ids, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<AccountMergeInner>> listAccountMergesWithHttpInfo(String ids, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listAccountMergesValidateBeforeCall(ids, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<AccountMergeInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listAccountMergesAsync(String ids, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<AccountMergeInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listAccountMergesValidateBeforeCall(ids, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<AccountMergeInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListAccountMergesRequestBuilder {
        private final String ids;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListAccountMergesRequestBuilder(String ids) {
            this.ids = ids;
        }

        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListAccountMergesRequestBuilder
         */
        public ListAccountMergesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListAccountMergesRequestBuilder
         */
        public ListAccountMergesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListAccountMergesRequestBuilder
         */
        public ListAccountMergesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListAccountMergesRequestBuilder
         */
        public ListAccountMergesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listAccountMerges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listAccountMergesCall(ids, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listAccountMerges request
         * @return List&lt;AccountMergeInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<AccountMergeInner> execute() throws ApiException {
            ApiResponse<List<AccountMergeInner>> localVarResp = listAccountMergesWithHttpInfo(ids, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listAccountMerges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;AccountMergeInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<AccountMergeInner>> executeWithHttpInfo() throws ApiException {
            return listAccountMergesWithHttpInfo(ids, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listAccountMerges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<AccountMergeInner>> _callback) throws ApiException {
            return listAccountMergesAsync(ids, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns a record of merges that have occurred involving the passed account ids.   This method allows you to take now invalid account ids and find what account they&#39;ve become, or take currently valid account ids and find which ids were equivalent in the past.   This is most useful when confirming that an account_id is in fact \&quot;new\&quot; to an application.   Account merges can happen for a wide range of reasons, applications should not make assumptions that merges have particular causes.   Note that accounts are managed at a network level, users on a site may be merged due to an account level merge but there is no guarantee that a merge has an effect on any particular site.   This method returns a list of account_merge. 
     * @param ids Number list (semicolon delimited). (required)
     * @return ListAccountMergesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListAccountMergesRequestBuilder listAccountMerges(String ids) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        return new ListAccountMergesRequestBuilder(ids);
    }
    private okhttp3.Call listElectedModeratorUsersCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/moderators/elected";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listElectedModeratorUsersValidateBeforeCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listElectedModeratorUsers(Async)");
        }

        return listElectedModeratorUsersCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<UsersInner>> listElectedModeratorUsersWithHttpInfo(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listElectedModeratorUsersValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listElectedModeratorUsersAsync(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<UsersInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listElectedModeratorUsersValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListElectedModeratorUsersRequestBuilder {
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListElectedModeratorUsersRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListElectedModeratorUsersRequestBuilder
         */
        public ListElectedModeratorUsersRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listElectedModeratorUsers
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listElectedModeratorUsersCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listElectedModeratorUsers request
         * @return List&lt;UsersInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<UsersInner> execute() throws ApiException {
            ApiResponse<List<UsersInner>> localVarResp = listElectedModeratorUsersWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listElectedModeratorUsers request with HTTP info returned
         * @return ApiResponse&lt;List&lt;UsersInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<UsersInner>> executeWithHttpInfo() throws ApiException {
            return listElectedModeratorUsersWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listElectedModeratorUsers request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<UsersInner>> _callback) throws ApiException {
            return listElectedModeratorUsersAsync(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns those users on a site who both have moderator powers, and were actually elected.   This method excludes Stack Exchange Inc. employees, unless they were actually elected moderators on a site (which can only have happened prior to their employment).   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListElectedModeratorUsersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListElectedModeratorUsersRequestBuilder listElectedModeratorUsers(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListElectedModeratorUsersRequestBuilder(site);
    }
    private okhttp3.Call listModeratorUsersCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/moderators";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listModeratorUsersValidateBeforeCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listModeratorUsers(Async)");
        }

        return listModeratorUsersCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<UsersInner>> listModeratorUsersWithHttpInfo(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listModeratorUsersValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listModeratorUsersAsync(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<UsersInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listModeratorUsersValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListModeratorUsersRequestBuilder {
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListModeratorUsersRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListModeratorUsersRequestBuilder
         */
        public ListModeratorUsersRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listModeratorUsers
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listModeratorUsersCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listModeratorUsers request
         * @return List&lt;UsersInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<UsersInner> execute() throws ApiException {
            ApiResponse<List<UsersInner>> localVarResp = listModeratorUsersWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listModeratorUsers request with HTTP info returned
         * @return ApiResponse&lt;List&lt;UsersInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<UsersInner>> executeWithHttpInfo() throws ApiException {
            return listModeratorUsersWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listModeratorUsers request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<UsersInner>> _callback) throws ApiException {
            return listModeratorUsersAsync(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets those users on a site who can exercise moderation powers.   Note, employees of Stack Exchange Inc. will be returned if they have been granted moderation powers on a site even if they have never been appointed or elected explicitly. This method checks abilities, not the manner in which they were obtained.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of users. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListModeratorUsersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListModeratorUsersRequestBuilder listModeratorUsers(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListModeratorUsersRequestBuilder(site);
    }
    private okhttp3.Call listNoAnswerQuestionsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/questions/no-answers"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listNoAnswerQuestionsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling listNoAnswerQuestions(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listNoAnswerQuestions(Async)");
        }

        return listNoAnswerQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<QuestionsInner>> listNoAnswerQuestionsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listNoAnswerQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listNoAnswerQuestionsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listNoAnswerQuestionsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<QuestionsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListNoAnswerQuestionsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListNoAnswerQuestionsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; activity &#x3D;&gt; date sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListNoAnswerQuestionsRequestBuilder
         */
        public ListNoAnswerQuestionsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listNoAnswerQuestions
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listNoAnswerQuestionsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listNoAnswerQuestions request
         * @return List&lt;QuestionsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<QuestionsInner> execute() throws ApiException {
            ApiResponse<List<QuestionsInner>> localVarResp = listNoAnswerQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listNoAnswerQuestions request with HTTP info returned
         * @return ApiResponse&lt;List&lt;QuestionsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<QuestionsInner>> executeWithHttpInfo() throws ApiException {
            return listNoAnswerQuestionsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listNoAnswerQuestions request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<QuestionsInner>> _callback) throws ApiException {
            return listNoAnswerQuestionsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the questions asked by the users in {ids} which have no answers.   Questions returns by this method actually have zero undeleted answers. It is completely disjoint /users/{ids}/questions/unanswered and /users/{ids}/questions/unaccepted, which only return questions with at least one answer, subject to other contraints.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the question object:  - activity - last_activity_date  - creation - creation_date  - votes - score   activity is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of questions. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListNoAnswerQuestionsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListNoAnswerQuestionsRequestBuilder listNoAnswerQuestions(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListNoAnswerQuestionsRequestBuilder(ids, site);
    }
    private okhttp3.Call listUserBadgesCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/badges"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listUserBadgesValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling listUserBadges(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listUserBadges(Async)");
        }

        return listUserBadgesCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<BadgesInner>> listUserBadgesWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listUserBadgesValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listUserBadgesAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<BadgesInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listUserBadgesValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<BadgesInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListUserBadgesRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListUserBadgesRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string sort &#x3D; awarded &#x3D;&gt; date  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; rank &#x3D;&gt; string sort &#x3D; name &#x3D;&gt; string sort &#x3D; type &#x3D;&gt; string sort &#x3D; awarded &#x3D;&gt; date  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListUserBadgesRequestBuilder
         */
        public ListUserBadgesRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listUserBadges
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listUserBadgesCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listUserBadges request
         * @return List&lt;BadgesInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<BadgesInner> execute() throws ApiException {
            ApiResponse<List<BadgesInner>> localVarResp = listUserBadgesWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listUserBadges request with HTTP info returned
         * @return ApiResponse&lt;List&lt;BadgesInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<BadgesInner>> executeWithHttpInfo() throws ApiException {
            return listUserBadgesWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listUserBadges request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<BadgesInner>> _callback) throws ApiException {
            return listUserBadgesAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Get the badges the users in {ids} have earned.   Badge sorts are a tad complicated. For the purposes of sorting (and min/max) tag_based is considered to be greater than named.   This means that you can get a list of all tag based badges a user has by passing min&#x3D;tag_based, and conversely all the named badges by passing max&#x3D;named, with sort&#x3D;type.   For ranks, bronze is greater than silver which is greater than gold. Along with sort&#x3D;rank, set max&#x3D;gold for just gold badges, max&#x3D;silver&amp;min&#x3D;silver for just silver, and min&#x3D;bronze for just bronze.   rank is the default sort.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   This method returns a list of badges. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListUserBadgesRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListUserBadgesRequestBuilder listUserBadges(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListUserBadgesRequestBuilder(ids, site);
    }
    private okhttp3.Call listUsersCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (inname != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("inname", inname));
        }

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listUsersValidateBeforeCall(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listUsers(Async)");
        }

        return listUsersCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<UsersInner>> listUsersWithHttpInfo(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listUsersValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listUsersAsync(String site, String inname, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<UsersInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listUsersValidateBeforeCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<UsersInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListUsersRequestBuilder {
        private final String site;
        private String inname;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListUsersRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set inname
         * @param inname  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder inname(String inname) {
            this.inname = inname;
            return this;
        }
        
        /**
         * Set order
         * @param order  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; reputation &#x3D;&gt; number sort &#x3D; creation &#x3D;&gt; date sort &#x3D; name &#x3D;&gt; string sort &#x3D; modified &#x3D;&gt; date  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListUsersRequestBuilder
         */
        public ListUsersRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listUsers
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listUsersCall(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listUsers request
         * @return List&lt;UsersInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<UsersInner> execute() throws ApiException {
            ApiResponse<List<UsersInner>> localVarResp = listUsersWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listUsers request with HTTP info returned
         * @return ApiResponse&lt;List&lt;UsersInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<UsersInner>> executeWithHttpInfo() throws ApiException {
            return listUsersWithHttpInfo(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listUsers request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<UsersInner>> _callback) throws ApiException {
            return listUsersAsync(site, inname, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns all users on a site.   This method returns a list of users.   The sorts accepted by this method operate on the follow fields of the user object:  - reputation - reputation  - creation - creation_date  - name - display_name  - modified - last_modified_date   reputation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     The inname parameter lets consumers filter the results down to just those users with a certain substring in their display name. For example, inname&#x3D;kevin will return all users with both users named simply \&quot;Kevin\&quot; or those with Kevin as one of (or part of) their names; such as \&quot;Kevin Montrose\&quot;. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListUsersRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListUsersRequestBuilder listUsers(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListUsersRequestBuilder(site);
    }
    private okhttp3.Call mentionedCommentsListCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/users/{ids}/mentioned"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call mentionedCommentsListValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling mentionedCommentsList(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling mentionedCommentsList(Async)");
        }

        return mentionedCommentsListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> mentionedCommentsListWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = mentionedCommentsListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call mentionedCommentsListAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = mentionedCommentsListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class MentionedCommentsListRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private MentionedCommentsListRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return MentionedCommentsListRequestBuilder
         */
        public MentionedCommentsListRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for mentionedCommentsList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return mentionedCommentsListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute mentionedCommentsList request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = mentionedCommentsListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute mentionedCommentsList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return mentionedCommentsListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute mentionedCommentsList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return mentionedCommentsListAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets all the comments that the users in {ids} were mentioned in.   Note, to count as a mention the comment must be considered to be \&quot;in reply to\&quot; a user. Most importantly, this means that a comment can only be in reply to a single user.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for user_id on user or shallow_user objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return MentionedCommentsListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public MentionedCommentsListRequestBuilder mentionedCommentsList(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new MentionedCommentsListRequestBuilder(ids, site);
    }
}
