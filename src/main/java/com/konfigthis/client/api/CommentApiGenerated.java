/*
 * StackExchange
 * Stack Exchange is a network of 130+ Q&A communities including Stack Overflow. 
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.konfigthis.client.model.CommentsInner;
import com.konfigthis.client.model.CreatedComment;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class CommentApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public CommentApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public CommentApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call deleteActionCall(Integer id, String site, String filter, String paramCallback, Boolean preview, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/comments/{id}/delete"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        if (preview != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preview", preview));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteActionValidateBeforeCall(Integer id, String site, String filter, String paramCallback, Boolean preview, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteAction(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling deleteAction(Async)");
        }

        return deleteActionCall(id, site, filter, paramCallback, preview, _callback);

    }


    private ApiResponse<Void> deleteActionWithHttpInfo(Integer id, String site, String filter, String paramCallback, Boolean preview) throws ApiException {
        okhttp3.Call localVarCall = deleteActionValidateBeforeCall(id, site, filter, paramCallback, preview, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call deleteActionAsync(Integer id, String site, String filter, String paramCallback, Boolean preview, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteActionValidateBeforeCall(id, site, filter, paramCallback, preview, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class DeleteActionRequestBuilder {
        private final Integer id;
        private final String site;
        private String filter;
        private String paramCallback;
        private Boolean preview;

        private DeleteActionRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return DeleteActionRequestBuilder
         */
        public DeleteActionRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return DeleteActionRequestBuilder
         */
        public DeleteActionRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Set preview
         * @param preview  (optional)
         * @return DeleteActionRequestBuilder
         */
        public DeleteActionRequestBuilder preview(Boolean preview) {
            this.preview = preview;
            return this;
        }
        
        /**
         * Build call for deleteAction
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return deleteActionCall(id, site, filter, paramCallback, preview, _callback);
        }


        /**
         * Execute deleteAction request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            deleteActionWithHttpInfo(id, site, filter, paramCallback, preview);
        }

        /**
         * Execute deleteAction request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return deleteActionWithHttpInfo(id, site, filter, paramCallback, preview);
        }

        /**
         * Execute deleteAction request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return deleteActionAsync(id, site, filter, paramCallback, preview, _callback);
        }
    }

    /**
     * 
     * Deletes a comment.   Use an access_token with write_access to delete a comment.   In practice, this method will never return an object. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return DeleteActionRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public DeleteActionRequestBuilder deleteAction(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new DeleteActionRequestBuilder(id, site);
    }
    private okhttp3.Call editExistingCall(Integer id, String site, String filter, String paramCallback, String body, Boolean preview, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/comments/{id}/edit"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        if (body != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("body", body));
        }

        if (preview != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("preview", preview));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call editExistingValidateBeforeCall(Integer id, String site, String filter, String paramCallback, String body, Boolean preview, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling editExisting(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling editExisting(Async)");
        }

        return editExistingCall(id, site, filter, paramCallback, body, preview, _callback);

    }


    private ApiResponse<CreatedComment> editExistingWithHttpInfo(Integer id, String site, String filter, String paramCallback, String body, Boolean preview) throws ApiException {
        okhttp3.Call localVarCall = editExistingValidateBeforeCall(id, site, filter, paramCallback, body, preview, null);
        Type localVarReturnType = new TypeToken<CreatedComment>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call editExistingAsync(Integer id, String site, String filter, String paramCallback, String body, Boolean preview, final ApiCallback<CreatedComment> _callback) throws ApiException {

        okhttp3.Call localVarCall = editExistingValidateBeforeCall(id, site, filter, paramCallback, body, preview, _callback);
        Type localVarReturnType = new TypeToken<CreatedComment>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class EditExistingRequestBuilder {
        private final Integer id;
        private final String site;
        private String filter;
        private String paramCallback;
        private String body;
        private Boolean preview;

        private EditExistingRequestBuilder(Integer id, String site) {
            this.id = id;
            this.site = site;
        }

        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return EditExistingRequestBuilder
         */
        public EditExistingRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return EditExistingRequestBuilder
         */
        public EditExistingRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Set body
         * @param body  (optional)
         * @return EditExistingRequestBuilder
         */
        public EditExistingRequestBuilder body(String body) {
            this.body = body;
            return this;
        }
        
        /**
         * Set preview
         * @param preview  (optional)
         * @return EditExistingRequestBuilder
         */
        public EditExistingRequestBuilder preview(Boolean preview) {
            this.preview = preview;
            return this;
        }
        
        /**
         * Build call for editExisting
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return editExistingCall(id, site, filter, paramCallback, body, preview, _callback);
        }


        /**
         * Execute editExisting request
         * @return CreatedComment
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public CreatedComment execute() throws ApiException {
            ApiResponse<CreatedComment> localVarResp = editExistingWithHttpInfo(id, site, filter, paramCallback, body, preview);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute editExisting request with HTTP info returned
         * @return ApiResponse&lt;CreatedComment&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<CreatedComment> executeWithHttpInfo() throws ApiException {
            return editExistingWithHttpInfo(id, site, filter, paramCallback, body, preview);
        }

        /**
         * Execute editExisting request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<CreatedComment> _callback) throws ApiException {
            return editExistingAsync(id, site, filter, paramCallback, body, preview, _callback);
        }
    }

    /**
     * 
     * Edit an existing comment.   Use an access_token with write_access to edit an existing comment.   This method return the created comment. 
     * @param id  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return EditExistingRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public EditExistingRequestBuilder editExisting(Integer id, String site) throws IllegalArgumentException {
        if (id == null) throw new IllegalArgumentException("\"id\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new EditExistingRequestBuilder(id, site);
    }
    private okhttp3.Call getCommentsByIdsCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/comments/{ids}"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCommentsByIdsValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getCommentsByIds(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getCommentsByIds(Async)");
        }

        return getCommentsByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> getCommentsByIdsWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getCommentsByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCommentsByIdsAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCommentsByIdsValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetCommentsByIdsRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetCommentsByIdsRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetCommentsByIdsRequestBuilder
         */
        public GetCommentsByIdsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getCommentsByIds
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCommentsByIdsCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getCommentsByIds request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = getCommentsByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getCommentsByIds request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return getCommentsByIdsWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getCommentsByIds request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return getCommentsByIdsAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the comments identified in id.   This method is most useful if you have a cache of comment ids obtained through other means (such as /questions/{id}/comments) but suspect the data may be stale.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for comment_id on comment objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetCommentsByIdsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetCommentsByIdsRequestBuilder getCommentsByIds(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetCommentsByIdsRequestBuilder(ids, site);
    }
    private okhttp3.Call getCommentsListCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/questions/{ids}/comments"
            .replace("{" + "ids" + "}", localVarApiClient.escapeString(ids.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCommentsListValidateBeforeCall(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling getCommentsList(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getCommentsList(Async)");
        }

        return getCommentsListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> getCommentsListWithHttpInfo(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getCommentsListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getCommentsListAsync(String ids, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getCommentsListValidateBeforeCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetCommentsListRequestBuilder {
        private final String ids;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetCommentsListRequestBuilder(String ids, String site) {
            this.ids = ids;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetCommentsListRequestBuilder
         */
        public GetCommentsListRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getCommentsList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getCommentsListCall(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getCommentsList request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = getCommentsListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getCommentsList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return getCommentsListWithHttpInfo(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getCommentsList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return getCommentsListAsync(ids, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets the comments on a question.   If you know that you have an question id and need the comments, use this method. If you know you have a answer id, use /answers/{ids}/comments. If you are unsure, use /posts/{ids}/comments.   {ids} can contain up to 100 semicolon delimited ids, to find ids programatically look for question_id on question objects.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param ids Number list (semicolon delimited). (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetCommentsListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetCommentsListRequestBuilder getCommentsList(String ids, String site) throws IllegalArgumentException {
        if (ids == null) throw new IllegalArgumentException("\"ids\" is required but got null");
            

        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetCommentsListRequestBuilder(ids, site);
    }
    private okhttp3.Call getReplyListCall(Integer toId, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/me/comments/{toId}"
            .replace("{" + "toId" + "}", localVarApiClient.escapeString(toId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getReplyListValidateBeforeCall(Integer toId, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'toId' is set
        if (toId == null) {
            throw new ApiException("Missing the required parameter 'toId' when calling getReplyList(Async)");
        }

        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling getReplyList(Async)");
        }

        return getReplyListCall(toId, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> getReplyListWithHttpInfo(Integer toId, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = getReplyListValidateBeforeCall(toId, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call getReplyListAsync(Integer toId, String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = getReplyListValidateBeforeCall(toId, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class GetReplyListRequestBuilder {
        private final Integer toId;
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private GetReplyListRequestBuilder(Integer toId, String site) {
            this.toId = toId;
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return GetReplyListRequestBuilder
         */
        public GetReplyListRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for getReplyList
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return getReplyListCall(toId, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute getReplyList request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = getReplyListWithHttpInfo(toId, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute getReplyList request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return getReplyListWithHttpInfo(toId, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute getReplyList request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return getReplyListAsync(toId, site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the comments owned by the user associated with the given access_token that are in reply to the user identified by {toId}.   This method returns a list of comments. 
     * @param toId  (required)
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return GetReplyListRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public GetReplyListRequestBuilder getReplyList(Integer toId, String site) throws IllegalArgumentException {
        if (toId == null) throw new IllegalArgumentException("\"toId\" is required but got null");
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new GetReplyListRequestBuilder(toId, site);
    }
    private okhttp3.Call listCommentsCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/comments";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listCommentsValidateBeforeCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listComments(Async)");
        }

        return listCommentsCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> listCommentsWithHttpInfo(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listCommentsValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listCommentsAsync(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listCommentsValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListCommentsRequestBuilder {
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListCommentsRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListCommentsRequestBuilder
         */
        public ListCommentsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listComments
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listCommentsCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listComments request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = listCommentsWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listComments request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return listCommentsWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listComments request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return listCommentsAsync(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Gets all the comments on the site.   If you&#39;re filtering for interesting comments (by score, creation date, etc.) make use of the sort paramter with appropriate min and max values.   If you&#39;re looking to query conversations between users, instead use the /users/{ids}/mentioned and /users/{ids}/comments/{toid} methods.   The sorts accepted by this method operate on the follow fields of the comment object:  - creation - creation_date  - votes - score   creation is the default sort.    It is possible to create moderately complex queries using sort, min, max, fromdate, and todate.     This method returns a list of comments. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListCommentsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListCommentsRequestBuilder listComments(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListCommentsRequestBuilder(site);
    }
    private okhttp3.Call listOwnedCommentsCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/me/comments";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (order != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("order", order));
        }

        if (max != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("max", max));
        }

        if (min != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("min", min));
        }

        if (sort != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("sort", sort));
        }

        if (fromdate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("fromdate", fromdate));
        }

        if (todate != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("todate", todate));
        }

        if (pagesize != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pagesize", pagesize));
        }

        if (page != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("page", page));
        }

        if (filter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("filter", filter));
        }

        if (paramCallback != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("callback", paramCallback));
        }

        if (site != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("site", site));
        }

        final String[] localVarAccepts = {
            "*/*"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listOwnedCommentsValidateBeforeCall(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'site' is set
        if (site == null) {
            throw new ApiException("Missing the required parameter 'site' when calling listOwnedComments(Async)");
        }

        return listOwnedCommentsCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);

    }


    private ApiResponse<List<CommentsInner>> listOwnedCommentsWithHttpInfo(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback) throws ApiException {
        okhttp3.Call localVarCall = listOwnedCommentsValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, null);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    private okhttp3.Call listOwnedCommentsAsync(String site, String order, String max, String min, String sort, Integer fromdate, Integer todate, Integer pagesize, Integer page, String filter, String paramCallback, final ApiCallback<List<CommentsInner>> _callback) throws ApiException {

        okhttp3.Call localVarCall = listOwnedCommentsValidateBeforeCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        Type localVarReturnType = new TypeToken<List<CommentsInner>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }

    public class ListOwnedCommentsRequestBuilder {
        private final String site;
        private String order;
        private String max;
        private String min;
        private String sort;
        private Integer fromdate;
        private Integer todate;
        private Integer pagesize;
        private Integer page;
        private String filter;
        private String paramCallback;

        private ListOwnedCommentsRequestBuilder(String site) {
            this.site = site;
        }

        /**
         * Set order
         * @param order  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder order(String order) {
            this.order = order;
            return this;
        }
        
        /**
         * Set max
         * @param max sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder max(String max) {
            this.max = max;
            return this;
        }
        
        /**
         * Set min
         * @param min sort &#x3D; creation &#x3D;&gt; date sort &#x3D; votes &#x3D;&gt; number  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder min(String min) {
            this.min = min;
            return this;
        }
        
        /**
         * Set sort
         * @param sort  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder sort(String sort) {
            this.sort = sort;
            return this;
        }
        
        /**
         * Set fromdate
         * @param fromdate Unix date. (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder fromdate(Integer fromdate) {
            this.fromdate = fromdate;
            return this;
        }
        
        /**
         * Set todate
         * @param todate Unix date. (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder todate(Integer todate) {
            this.todate = todate;
            return this;
        }
        
        /**
         * Set pagesize
         * @param pagesize  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder pagesize(Integer pagesize) {
            this.pagesize = pagesize;
            return this;
        }
        
        /**
         * Set page
         * @param page  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder page(Integer page) {
            this.page = page;
            return this;
        }
        
        /**
         * Set filter
         * @param filter #Discussion  The Stack Exchange API allows applications to exclude almost every field returned. For example, if an application did not care about a user&#39;s badge counts it could exclude user.badge_counts whenever it calls a method that returns users.  An application excludes fields by creating a filter (via /filter/create) and passing it to a method in the filter parameter.  Filters are immutable and non-expiring. An application can safely \&quot;bake in\&quot; any filters that are created, it is not necessary (or advisable) to create filters at runtime.  The motivation for filters are several fold. Filters allow applications to reduce API responses to just the fields they are concerned with, saving bandwidth. With the list of fields an application is actually concerned with, the API can avoid unneccessary queries thereby decreasing response time (and reducing load on our infrastructure). Finally, filters allow us to be more conservative in what the API returns by default without a proliferation of parameters (as was seen with body, answers, and comments in the 1.x API family).  #Safety  Filters also carry a notion of safety, which is defined as follows. Any string returned as a result of an API call with a safe filter will be inline-able into HTML without script-injection concerns. That is to say, no additional sanitizing (encoding, HTML tag stripping, etc.) will be necessary on returned strings. Applications that wish to handle sanitizing themselves should create an unsafe filter. All filters are safe by default, under the assumption that double-encoding bugs are more desirable than script injections.  Note that this does not mean that \&quot;safe\&quot; filter is mearly an \&quot;unsafe\&quot; one with all fields passed though UrlEncode(...). Many fields can and will contain HTML in all filter types (most notably, the *.body fields).  When using unsafe filters, the API returns the highest fidelity data it can reasonably access for the given request. This means that in cases where the \&quot;safe\&quot; data is the only accessible data it will be returned even in \&quot;unsafe\&quot; filters. Notably the *.body fields are unchanged, as they are stored in that form. Fields that are unchanged between safe and unsafe filters are denoted in their types documentation.  #Built In Filters  The following filters are built in:  default, each type documents which fields are returned under the default filter (for example, answers). withbody, which is default plus the *.body fields none, which is empty total, which includes just .total  #Compatibility with V1.x  For ease of transition from earlier API versions, the filters _b, _ba, _bc, _bca, _a, _ac, and _c are also built in. These are unsafe, and exclude a combination of question and answer body, comments, and answers so as to mimic the body, answers, and comments parameters that have been removed in V2.0. New applications should not use these filters.  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder filter(String filter) {
            this.filter = filter;
            return this;
        }
        
        /**
         * Set paramCallback
         * @param paramCallback All API responses are JSON, we do support JSONP with the callback query parameter.  (optional)
         * @return ListOwnedCommentsRequestBuilder
         */
        public ListOwnedCommentsRequestBuilder paramCallback(String paramCallback) {
            this.paramCallback = paramCallback;
            return this;
        }
        
        /**
         * Build call for listOwnedComments
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listOwnedCommentsCall(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }


        /**
         * Execute listOwnedComments request
         * @return List&lt;CommentsInner&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public List<CommentsInner> execute() throws ApiException {
            ApiResponse<List<CommentsInner>> localVarResp = listOwnedCommentsWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
            return localVarResp.getResponseBody();
        }

        /**
         * Execute listOwnedComments request with HTTP info returned
         * @return ApiResponse&lt;List&lt;CommentsInner&gt;&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<List<CommentsInner>> executeWithHttpInfo() throws ApiException {
            return listOwnedCommentsWithHttpInfo(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback);
        }

        /**
         * Execute listOwnedComments request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
            <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
            <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
            <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
            <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
            <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
            <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
            <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
            <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
            <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
            <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<List<CommentsInner>> _callback) throws ApiException {
            return listOwnedCommentsAsync(site, order, max, min, sort, fromdate, todate, pagesize, page, filter, paramCallback, _callback);
        }
    }

    /**
     * 
     * Returns the comments owned by the user associated with the given access_token.   This method returns a list of comments. 
     * @param site Each of these methods operates on a single site at a time, identified by the site parameter. This parameter can be the full domain name (ie. \&quot;stackoverflow.com\&quot;), or a short form identified by api_site_parameter on the site object.  (required)
     * @return ListOwnedCommentsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> bad_parameter Ã¢â‚¬â€œ 400 An invalid parameter was passed, this includes even \&quot;high level\&quot; parameters like key or site.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> access_token_required Ã¢â‚¬â€œ 401 A method that requires an access token (obtained via authentication) was called without one.  </td><td>  -  </td></tr>
        <tr><td> 402 </td><td> invalid_access_token Ã¢â‚¬â€œ 402 An invalid access token was passed to a method.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> access_denied Ã¢â‚¬â€œ 403 A method which requires certain permissions was called with an access token that lacks those permissions.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> no_method Ã¢â‚¬â€œ 404 An attempt was made to call a method that does not exist. Note, calling methods that expect numeric ids (like /users/{ids}) with non-numeric ids can also result in this error.  </td><td>  -  </td></tr>
        <tr><td> 405 </td><td> key_required Ã¢â‚¬â€œ 405 A method was called in a manner that requires an application key (generally, with an access token), but no key was passed.  </td><td>  -  </td></tr>
        <tr><td> 406 </td><td> access_token_compromised Ã¢â‚¬â€œ 406 An access token is no longer believed to be secure, normally because it was used on a non-HTTPS call. The access token will be invalidated if this error is returned.  </td><td>  -  </td></tr>
        <tr><td> 500 </td><td> internal_error Ã¢â‚¬â€œ 500 An unexpected error occurred in the API. It has been logged, and Stack Exchange developers have been notified. You should report these errors on Stack Apps if you want to be notified when they&#39;re fixed.  </td><td>  -  </td></tr>
        <tr><td> 502 </td><td> throttle_violation Ã¢â‚¬â€œ 502 An application has violated part of the rate limiting contract, so the request was terminated.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> temporarily_unavailable Ã¢â‚¬â€œ 503 Some or all of the API is unavailable. Applications should backoff on requests to the method invoked.  </td><td>  -  </td></tr>
     </table>
     */
    public ListOwnedCommentsRequestBuilder listOwnedComments(String site) throws IllegalArgumentException {
        if (site == null) throw new IllegalArgumentException("\"site\" is required but got null");
            

        return new ListOwnedCommentsRequestBuilder(site);
    }
}
